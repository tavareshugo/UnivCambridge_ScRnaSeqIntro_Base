---
title: "Introduction to single-cell RNA-seq analysis"
date: "Sept 2022"
subtitle: Differencial Expression and Abundance
output:
  html_document:
    toc: yes
    toc_float: true
    toc_depth: 2
    number_sections: true
    css: ../css/boxes.css
    includes:
      in_header: ../css/navbar.html
---

```{r setup_wd}
knitr::opts_knit$set(root.dir = here::here("course_files"))
```

```{r setup, echo=FALSE, include=FALSE, message=FALSE, purl=FALSE}
library(scater)
library(scran)
library(batchelor)
library(edgeR)
library(tidyverse)
library(patchwork)
library(DT)
library(bluster)
library(BiocParallel)
library(miloR)

knitr::opts_chunk$set(error=FALSE, 
                      message=FALSE, 
                      warning=FALSE, 
                      cache=TRUE, 
                      purl=TRUE)
set.seed(123)
```


Acknowledgments: much of the material in this section has been derived from the 
chapters on differential expression and abundance in the
[OSCA book](http://bioconductor.org/books/3.14/OSCA.basic/normalization.html) 
and the [Hemberg Group course materials](https://www.singlecellcourse.org/). Additional material concerning `miloR` has been based on the [demonstration from the Marioni Lab.](https://marionilab.github.io/miloR/articles/milo_gastrulation.html)

# Differential expression and abundance between conditions 



## Motivation

A powerful use of scRNA-seq technology lies in the design of replicated multi-condition experiments to detect changes in composition or expression between conditions. This can provide more biological insight than conventional scRNA-seq experiments involving only one biological condition, especially if we can relate population changes to specific biological states.

Differential analyses of multi-condition scRNA-seq experiments can be broadly split into two categories - differential expression (DE) and differential abundance (DA) analyses. The former tests for changes in expression between conditions for cells of the same 'type' that are present in both conditions, while the latter tests for changes in the composition of cell types (or states, etc.) between conditions.

## Setup

```{r load_packages, eval=FALSE}
library(scater)
library(scran)
library(batchelor)
library(edgeR)
library(tidyverse)
library(patchwork)
library(DT)
library(bluster)
library(BiocParallel)
library(miloR)

bpp <- MulticoreParam(7)
```

## Setting up the data

Due to the nature of differencial analysis we cannot use the downsampled version of the dataset for the this section so we have the full Caron dataset. We will start with just the PBMMC and ETV6-RUNX1 samples. It has been QCed, normalised and batch corrected as shown last week and clustered as shown this morning. We have selected the Leiden clustering with k=60 to go forward.

Load the SCE object:

```{r read_data, cache=FALSE}

sce <- readRDS("R_objects/Caron_clustered.PBMMCandETV6RUNX1.rds")

rownames(sce) <- uniquifyFeatureNames(rownames(sce), rowData(sce)$Symbol)

sce
```

We can plot any of the outputs of the dimensionality reduction in the reduced dimensions slot of the single cell object. 

```{r plot_TSNE_1}

plotReducedDim(sce, dimred = "TSNE_corrected", colour_by = "label")

```


## Differential expression between conditions

### Creating pseudo-bulk samples

The most obvious differential analysis is to look for changes in expression between conditions. We perform the DE analysis separately for each label. The actual DE testing is performed on “pseudo-bulk” expression profiles (Tung et al. 2017), generated by summing counts together for all cells with the same combination of label and sample. This leverages the resolution offered by single-cell technologies to define the labels, and combines it with the statistical rigor of existing methods for DE analyses involving a small number of samples.

Here we use `label` and `SampleName` as the parameter to aggregate by. This means for each true sample there will be a pseudo-sample for each of our defined clusters. We therefore would have a maximum of 7x17 (119) pseudo-samples. We will have less than this as there will be a few clusters with no cells from a particular sample.

```{r aggregate_cells}

summed <- aggregateAcrossCells(sce, 
                               id=colData(sce)[,c("label", "SampleName")])
summed
```

At this point, it is worth reflecting on the motivations behind the use of pseudo-bulking:

Larger counts are more amenable to standard DE analysis pipelines designed for bulk RNA-seq data. Normalization is more straightforward and certain statistical approximations are more accurate e.g., the saddlepoint approximation for quasi-likelihood methods or normality for linear models.
Collapsing cells into samples reflects the fact that our biological replication occurs at the sample level (Lun and Marioni 2017). Each sample is represented no more than once for each condition, avoiding problems from unmodelled correlations between samples. Supplying the per-cell counts directly to a DE analysis pipeline would imply that each cell is an independent biological replicate, which is not true from an experimental perspective. (A mixed effects model can handle this variance structure but involves extra statistical and computational complexity for little benefit, see Crowell et al. (2019).)
Variance between cells within each sample is masked, provided it does not affect variance across (replicate) samples. This avoids penalizing DEGs that are not uniformly up- or down-regulated for all cells in all samples of one condition. Masking is generally desirable as DEGs - unlike marker genes - do not need to have low within-sample variance to be interesting, e.g., if the treatment effect is consistent across replicate populations but heterogeneous on a per-cell basis. (Of course, high per-cell variability will still result in weaker DE if it affects the variability across populations, while homogeneous per-cell responses will result in stronger DE due to a larger population-level log-fold change. These effects are also largely desirable.)

### Performing the DE analysis

#### Introduction

The DE analysis will be performed using quasi-likelihood (QL) methods from the `edgeR` package (Robinson, McCarthy, and Smyth 2010; Chen, Lun, and Smyth 2016). This uses a negative binomial generalized linear model (NB GLM) to handle overdispersed count data in experiments with limited replication. In our case, we have biological variation with few replicates per sample group, so `edgeR` (or its contemporaries) is a natural choice for the analysis. You can read more about the `edgeR` package and how each step is being calculated here: (edgeR user guide)[https://bioconductor.org/packages/release/bioc/vignettes/edgeR/inst/doc/edgeRUsersGuide.pdf]

It is possible to use `DESeq2` here instead, the OSCA book uses `edgeR` so we have stuck to that but it is up to you.

We do not use all labels for GLM fitting as the strong DE between labels makes it difficult to compute a sensible average abundance to model the mean-dispersion trend. Moreover, label-specific batch effects would not be easily handled with a single additive term in the design matrix for the batch. Instead, we picked one of the labels to use for this demonstration.

```{r choose_cluster_and_subset}

current <- summed[,summed$label == "1"]

colData(current)

```

In order to use edgeR we must have the data stored in a `DGEList` object. For this we need our counts matrix and a data frame containing metadata on our pseudo-samples.

```{r make_edgeR_object}

countsToUse <- counts(current)
colnames(countsToUse) <- colData(current)$SampleName

y <- DGEList(countsToUse, samples=colData(current))
y

```

#### Pre-processing

A typical step in bulk RNA-seq data analyses is to remove samples with very low library sizes due to failed library preparation or sequencing. The very low counts in these samples can be troublesome in downstream steps such as normalization or for some statistical approximations used in the DE analysis. In our situation, this is equivalent to removing label-sample combinations that have very few or lowly-sequenced cells. The exact definition of “very low” will vary, but in this case, we remove combinations containing fewer than 20 cells (Crowell et al. 2019).

```{r discard_low_cells}
discarded <- current$ncells < 20
y <- y[,!discarded]
summary(discarded)
```

Another typical step in bulk RNA-seq analyses is to remove genes that are lowly expressed. This reduces computational work, improves the accuracy of mean-variance trend modelling and decreases the severity of the multiple testing correction. Genes are discarded if they are not expressed above a log-CPM threshold in a minimum number of samples (determined from the size of the smallest treatment group in the experimental design). The `filterByExpr` function keeps rows that have 'worthwhile' counts in a minimum number of samples In this case the minimum number would be 3 as that is the smallest SampleGroup size.

```{r remove_low_genes}

keep <- filterByExpr(y, group=current$SampleGroup)
y <- y[keep,]
summary(keep)

```

Finally, we correct for composition biases by computing normalization factors with the trimmed mean of M-values method (Robinson and Oshlack 2010). Counts for our pseudo-bulk samples are large enough to apply bulk normalization methods. In the case of single cell data this is helping to account for the differing numbers of cell counts that have been summed to produce the pseudo-samples.

```{r calc_norm_factors}

y <- calcNormFactors(y)
y$samples

```


As part of the usual diagnostics for a bulk RNA-seq DE analysis, we generate a mean-difference (MD) plot for each normalized pseudo-bulk profile. This should exhibit a trumpet shape centered at zero indicating that the normalization successfully removed systematic bias between profiles. Lack of zero-centering or dominant discrete patterns at low abundances may be symptomatic of deeper problems with normalization, possibly due to insufficient cells/reads/UMIs composing a particular pseudo-bulk profile.

```{r plot_MD}
par(mfrow=c(2,4))
for (i in seq_len(ncol(y))) {
    plotMD(y, column=i)
}
```


We also generate a multi-dimensional scaling (MDS) plot for the pseudo-bulk profiles. 
MDS arranges the points on the plot so that the distances among each pair of points 
correlates as best as possible to the dissimilarity between those two samples. The 
values on the two axes tell you nothing about the variables for a given sample - the 
plot is just a two dimensional space to arrange the points. You can think of this in a 
similar way to how you would read a PCA plot in bulk RNASeq as it allows us to visualize 
the structure of the data. The aim is to check whether samples separate by our known 
factors of interest. Strong separation foreshadows a large number of DEGs in the 
subsequent analysis.

```{r plot_MDS}
y$samples$SampleGroup <- factor(y$samples$SampleGroup)
limma::plotMDS(cpm(y, log=TRUE), col = as.numeric(y$samples$SampleGroup))
```

#### Statistical modelling

Our aim is to test whether the log-fold change between sample groups is significantly different from zero.

```{r design_model}
design <- model.matrix(~factor(SampleGroup), y$samples)
design
```

We estimate the negative binomial (NB) dispersions with estimateDisp(). The role of the NB dispersion is to model the mean-variance trend, which is not easily accommodated by QL dispersions alone due to the quadratic nature of the NB mean-variance trend.

```{r estimate_dispersions}
y <- estimateDisp(y, design)
```

When a negative binomial model is fitted, we need to estimate the BCV(s) before we carry out
the analysis. Biological coefficient of variation (BCV) for each gene as a function of the average abundance. The BCV is computed as the square root of the NB dispersion after empirical Bayes shrinkage towards the trend.  Hence, it is equivalent to estimating the dispersion(s) of the negative binomial model. Trended and common BCV estimates are shown in blue and red, respectively. 

```{r plot_BCV}
plotBCV(y)
```

We also estimate the quasi-likelihood dispersions with glmQLFit() (Chen, Lun, and Smyth 2016). This fits a GLM to the counts for each gene and estimates the QL dispersion from the GLM deviance. We set robust=TRUE to avoid distortions from highly variable clusters (Phipson et al. 2016). The QL dispersion models the uncertainty and variability of the per-gene variance - which is not well handled by the NB dispersions, so the two dispersion types complement each other in the final analysis.

```{r fit_QL}
fit <- glmQLFit(y, design, robust=TRUE)
```

QL dispersion estimates for each gene as a function of abundance. Raw estimates (black) are shrunk towards the trend (blue) to yield squeezed estimates (red).

```{r plot_QL_dispersion}
plotQLDisp(fit)
```

We test for differences in expression due to sample group using glmQLFTest(). The QLF-test is preferred to a likelihood ratio test as it reflects the uncertainty in estimating the dispersion for each gene. DEGs are defined as those with non-zero log-fold changes at a false discovery rate of 5%. If very few genes are significantly DE that sample group has little effect on the transcriptome.

The `coef` argument specifies which contrast you want tested. It is the number of the column in the model matrix. For us since we only have 2 columns in our model matrix (the intercept and PBMMC vs ETV6-RUNX1) we can specify this as "2".

```{r perform_DEA}
results <- glmQLFTest(fit, coef = 2)
summary(decideTests(results))
```

We can get the results of our comparison using the `topTags` function. By default this function will output the top 10 genes by FDR but you could change this using the `n =` argument.

```{r get_results}
topTags(results)
```

### Putting it all together

Now that we have laid out the theory underlying the DE analysis, we repeat this process for each of the labels. This is conveniently done using the `pseudoBulkDGE` function from `scran`, which will loop over all labels and apply the exact analysis described above to each label. To prepare for this, we filter out all sample-label combinations with insufficient cells.

```{r filter_summed_counts}
summed.filt <- summed[,summed$ncells >= 20]
```

We construct a common design matrix that will be used in the analysis for each label. Recall that this matrix should have one row per unique sample (and named as such), reflecting the fact that we are modelling counts on the sample level instead of the cell level.

```{r get_common_metadata}

targets <- colData(sce)[!duplicated(sce$SampleName),] %>%
  data.frame()
```

```{r design_matrix_for_looping}

design <- model.matrix(~factor(SampleGroup), data=targets)
rownames(design) <- targets$SampleName
```

We then apply the `pseudoBulkDGE` function to obtain a list of DE genes for each label. This function puts some additional effort into automatically dealing with labels that are not represented in all sample groups, for which a DE analysis between conditions is meaningless; or are not represented in a sufficient number of replicate samples to enable modelling of biological variability.

```{r run_DEA_loop}
summed.filt$SampleGroup <- factor(summed.filt$SampleGroup)

de.results <- pseudoBulkDGE(summed.filt, 
    label = summed.filt$label,
    design = ~SampleGroup,
    coef = "SampleGroupPBMMC",
    condition = summed.filt$SampleName
)

de.results

de.results[[1]]
```

We examine the numbers of DEGs at a FDR of 5% for each label using the `decideTestsPerLabel` function. Note that genes listed as NA were either filtered out as low-abundance genes for a given label’s analysis, or the comparison of interest was not possible for a particular label, e.g., due to lack of residual degrees of freedom or an absence of samples from both conditions.

```{r per_label_DEGs}
is.de <- decideTestsPerLabel(de.results, threshold=0.05)
summarizeTestsPerLabel(is.de)
```


For each gene, we compute the percentage of labels in which that gene is upregulated or downregulated. (Here, we consider a gene to be non-DE if it is not retained after filtering.).

```{r upregulated_genes}

up.de <- is.de > 0 & !is.na(is.de)
head(sort(rowMeans(up.de), decreasing=TRUE), 10)
```

```{r downregulated_genes}

down.de <- is.de < 0 & !is.na(is.de)
head(sort(rowMeans(down.de), decreasing=TRUE), 10)
```

We further identify label-specific DE genes that are significant in our label of interest yet not DE in any other label. As hypothesis tests are not typically geared towards identifying genes that are not DE, we use an ad hoc approach where we consider a gene to be consistent with the null hypothesis for a label if it fails to be detected even at a generous FDR threshold of 50%.

```{r de_in_1_but_not_in_rest}
remotely.de <- decideTestsPerLabel(de.results, threshold=0.5)
not.de <- remotely.de==0 | is.na(remotely.de)

cx <- "1"

other.labels <- setdiff(colnames(not.de), cx)

unique.degs <- is.de[,cx]!=0 & rowMeans(not.de[,other.labels])==1
unique.degs <- names(which(unique.degs))
head(unique.degs)
```

Another thing we may be interested in is to inspect the top significantly differential expressed gene. To avoid an error caused by negative size factors and since we don't need them here we remove the size factors from the summed and filtered single cell object `summed.filt`.

```{r}
top_gene <- rownames(de.results[[1]][order(de.results[[1]]$FDR),])[1]

sizeFactors(summed.filt) <- NULL

plotExpression(logNormCounts(summed.filt), 
    features=top_gene,
    x="SampleName", colour_by="SampleName", 
    other_fields="label") + 
    facet_wrap(~label) +
  ggtitle(top_gene)
```


## Exercise 1

:::exercise

See the accompanying worksheet for this session, which includes the code below
for the exercise. We want to achieve the following:

- Rerun the differential expression analysis using the PRE-T and HHD samples.

- Determine which cluster has the most DEGs?

- Determine which genes are significantly DE in that cluster and not in any other?

```{r exercise1, eval=FALSE}
# First load in the other two sample groups
sce_PRET_HHD <- readRDS("R_objects/Caron_clustered.PRETandHHD.rds")

# replace the ensembl IDs with gene symbols where possible
rownames(sce_PRET_HHD) <- uniquifyFeatureNames(rownames(sce_PRET_HHD), rowData(sce_PRET_HHD)$Symbol)

# check your sce object
sce_PRET_HHD

# Part A
# Re run the analysis using these new samples.

FIXME

# Part B
# Looking at your results, which cluster has the most DEGs?

FIXME

# Part C
# Which genes are sig. DE in that cluster and not the others?

FIXME

```

<details><summary>Hint A</summary>

You can copy and paste from the previous code and just change which object is used.

</details>

<details><summary>Hint B</summary>

You will need to run pseudoBulkDGE to get the results for all the clusters at once.

</details>

<details><summary>Hint C</summary>

You can copy and paste this code from earlier too, but remember to replace the number of the cluster with the one you found in Part B.

</details>

<details><summary>Answer</summary>

Here is the complete script: 

```{r exercise1_solution, eval=FALSE}
# First load in the other two sample groups
sce_PRET_HHD <- readRDS("R_objects/Caron_clustered.PRETandHHD.rds")

# replace the ensembl IDs with gene symbols where possible
rownames(sce_PRET_HHD) <- uniquifyFeatureNames(rownames(sce_PRET_HHD), rowData(sce_PRET_HHD)$Symbol)

# check your sce object
sce_PRET_HHD

# Part A
# Re run the analysis using these new samples.
summed_PRET_HHD <- aggregateAcrossCells(sce_PRET_HHD, 
                               id=colData(sce_PRET_HHD)[,c("label", "SampleName")])
summed_PRET_HHD

summed_PRET_HHD.filt <- summed_PRET_HHD[,summed_PRET_HHD$ncells >= 20]

targets_PRET_HHD <- colData(sce_PRET_HHD)[!duplicated(sce_PRET_HHD$SampleName),] %>%
  data.frame()

design_PRET_HHD <- model.matrix(~factor(SampleGroup), data=targets_PRET_HHD)
rownames(design_PRET_HHD) <- targets_PRET_HHD$SampleName

summed_PRET_HHD.filt$SampleGroup <- factor(summed_PRET_HHD.filt$SampleGroup)

de.results_PRET_HHD <- pseudoBulkDGE(summed_PRET_HHD.filt, 
                            label = summed_PRET_HHD.filt$label,
                            design = ~SampleGroup,
                            coef = "SampleGroupPRE-T",
                            condition = summed_PRET_HHD.filt$SampleName)

# Part B
# Looking at your results, which cluster has the most DEGs?

is.de_PRET_HHD <- decideTestsPerLabel(de.results_PRET_HHD, threshold=0.05)
summarizeTestsPerLabel(is.de_PRET_HHD)

# Part C
# Which genes are sig. DE in that cluster and not the others?

remotely.de_PRET_HHD <- decideTestsPerLabel(de.results_PRET_HHD, threshold=0.5)
not.de_PRET_HHD <- remotely.de_PRET_HHD==0 | is.na(remotely.de_PRET_HHD)

cz <- "2"

other.labels_PRET_HHD <- setdiff(colnames(not.de_PRET_HHD), cz)

unique.degs_PRET_HHD <- is.de_PRET_HHD[,cz]!=0 & rowMeans(not.de_PRET_HHD[,other.labels_PRET_HHD])==1
unique.degs_PRET_HHD <- names(which(unique.degs_PRET_HHD))
head(unique.degs_PRET_HHD)
```


</details>

:::

### Differences between celltypes

The above example of differential expression focused on testing for differences in expression between conditions for the same cell type or label. However, the same methodology can be applied to test for differences between cell types across samples. This kind of DE analysis can overcome a lack of suitable replication.  

Using a dummy value for the label to allow us to include multiple cell types
in the fitted model; otherwise, each cell type will be processed separately.

```{r multi_cluster_DE}
summed.sub <- summed[,summed$label %in% c("3", "4")]

between.res <- pseudoBulkDGE(summed.sub,
    label=rep("dummy", ncol(summed.sub)),
    design=~factor(SampleName) + factor(label),
    coef="factor(label)4")[[1]]

table(Sig=between.res$FDR <= 0.05, Sign=sign(between.res$logFC))

```

```{r multi_cluster_DE_results}
between.res[order(between.res$FDR),]
```

```{r multi_cluster_DE_plots}
summed.sub <- logNormCounts(summed.sub, size.factors=NULL)
plotExpression(summed.sub, 
    features=head(rownames(between.res)[order(between.res$FDR)]),
    x="label", 
    colour_by=I(factor(summed.sub$SampleName)))
```

Whether or not this is a scientifically meaningful comparison depends on the nature of the labels. These particular labels were defined by clustering, which means that the presence of DEGs is a foregone conclusion. Nonetheless, it may have some utility for applications where the labels are defined using independent information, e.g., from FACS.


## Differential abundance between conditions

### Overview

In a DA analysis, we test for significant changes in per-label cell abundance across conditions. This will reveal which cell types are depleted or enriched upon treatment, which is arguably just as interesting as changes in expression within each cell type. The DA analysis has a long history in flow cytometry (Finak et al. 2014; Lun, Richard, and Marioni 2017) where it is routinely used to examine the effects of different conditions on the composition of complex cell populations. By performing it here, we effectively treat scRNA-seq as a “super-FACS” technology for defining relevant subpopulations using the entire transcriptome.

In the past we have demonstrated how to do this by using edgeR on a matrix of samples and clusters similar to the pseudo-samples but the 'counts' are cell numbers. Recently the same group who are responsible for the rest of the scater/scran tool kit have published `miloR` which has some advantages over directly using edgeR in this way.

MiloR uses methods based on (cydar)[https://www.nature.com/articles/nmeth.4295] which was designed for mass cytometry data although it does use the Negative Binomial GLM implementation from the edgeR package.

While differential abundance (DA) is commonly quantified in discrete cell clusters, Milo uses partally overlapping neighbourhoods of cells on a KNN graph, this means it isn't dependent on our clustering results. Starting from a graph that faithfully recapitulates the biology of the cell population, Milo analysis consists of 3 steps:

- Sampling of representative neighbourhoods
- Testing for differential abundance of conditions in all neighbourhoods
- Accounting for multiple hypothesis testing using a weighted FDR procedure that accounts for the overlap of neighbourhoods

### Create a Milo Object

The first step is to turn our single cell object into a Milo specific object. This is very similar but includes extra slots where we can store the neighbourhood information we generate.

```{r make_milo_object}

milo <- Milo(sce)

milo
```

### Construct KNN graph

We need to add the KNN graph to the Milo object. This is stored in the graph slot, in igraph format. The miloR package includes functionality to build and store the graph from the PCA dimensions stored in the reducedDim slot. Instead of the standard PCA we will use our MNN batch corrected PCA dimensions. The two parameters important to set here are `k` for the number of nearest neighbours for graph building and `d` for the number of our reduced dimensions to use. 

```{r build_Graph, message=FALSE}

milo <- buildGraph(milo, k = 60, d = 30, reduced.dim = "corrected", BPPARAM = MulticoreParam(7))
```

### Define neighbourhoods on the KNN graph

We define the neighbourhood of a cell, the index, as the group of cells connected by an edge in the KNN graph to the index cell. For efficiency, we don’t test for DA in the neighbourhood of every cell, but we sample as indices a subset of representative cells, using a KNN sampling algorithm used by (Gut et al. 2015)[https://www.nature.com/articles/nmeth.3545].

For sampling you need to define a few parameters:

prop: the proportion of cells to randomly sample to start with (usually 0.1 - 0.2 is sufficient)
k: the k to use for KNN refinement (we recommend using the same k used for KNN graph building)
d: the number of reduced dimensions to use for KNN refinement (we recommend using the same d used for KNN graph building)
refined: indicates whether you want to use the sampling refinement algorithm, or just pick cells at random. The default and recommended way to go is to use refinement. The only situation in which you might consider using random instead, is if you have batch corrected your data with a graph based correction algorithm, such as BBKNN, but the results of DA testing will be suboptimal.

```{r make_neighbourhoods, message=FALSE}

milo <- makeNhoods(milo, prop = 0.1, k = 60, d=30, refined = TRUE, reduced_dims = "corrected")
```

Once we have defined neighbourhoods, it’s good to take a look at how big the neighbourhoods are (i.e. how many cells form each neighbourhood). This affects the power of DA testing. We can check this out using the plotNhoodSizeHist function. 

The authors of Milo have stated several different parameters of deciding if your histogram is correct. Either 'peaking above 20', 'peaking between 50 and 100' or 'an average neighbourhood size over 5 x N_samples'. The tool is still in development. Realistically all of these statements give numbers in the same ballpark and so we can make a judgement on our data. If our histogram looks outside this we might consider rerunning makeNhoods increasing k and/or prop.

```{r plot_neighbourhood_sizes, message=FALSE}

plotNhoodSizeHist(milo)
```

### Counting cells in neighbourhoods

Milo leverages the variation in cell numbers between replicates for the same experimental condition to test for differential abundance. Therefore we have to count how many cells from each sample are in each neighbourhood. We need to use the cell metadata and specify which column contains the sample information.

This adds to the Milo object a n×m matrix, where n is the number of neighbourhoods and m is the number of experimental samples. Values indicate the number of cells from each sample counted in a neighbourhood. This count matrix will be used for DA testing.

```{r count_cells, message=FALSE}

milo <- countCells(milo, meta.data = data.frame(colData(milo)), sample="SampleName")

head(nhoodCounts(milo))
```

### Defining the experimental design

Now we are all set to test for differential abundance in neighbourhoods. We implement this hypothesis testing in a generalized linear model (GLM) framework, specifically using the Negative Binomial GLM implementation in edgeR.

We first need to think about our experimental design. The design matrix should match each sample to the experimental condition of interest for DA testing. In this case, we want to detect DA between our PBMMC and ETV6-RUNX1 sample groups. We could also include a batch column in the design matrix at this point but to keep the demonstration simple we will skip this. We would normally do this as we know there is a batch effect that we want to account for in DA testing.

```{r milo_design, message=FALSE}

milo_design <- data.frame(colData(milo))[,c("SampleName", "SampleGroup")]
milo_design <- distinct(milo_design)
rownames(milo_design) <- milo_design$SampleName

milo_design
```

### Computing neighbourhood connectivity

Milo uses an adaptation of the Spatial FDR correction introduced by cydar, where we correct p-values accounting for the amount of overlap between neighbourhoods. Specifically, each hypothesis test P-value is weighted by the reciprocal of the kth nearest neighbour distance. To use this statistic we first need to store the distances between nearest neighbors in the Milo object. This is done by the calcNhoodDistance function (N.B. this step is the most time consuming of the analysis workflow and might take a couple of minutes for large datasets). 

It is important to note the value for `d` here should match what was used for constructing the KNN graph and also that if a reduced dimension output it will default to PCA.

```{r calcultate_neighbourhood_distance, message=FALSE}

milo <- calcNhoodDistance(milo, d=30, reduced.dim = "corrected")
```

### Testing

Now we can do the DA test, explicitly defining our experimental design. In this case as discussed we will test the difference between sample groups. The `testNhoods` function calculates a Fold-change and corrected P-value for each neighbourhood, which indicates whether there is significant differential abundance between sample groups.

```{r test_neighbourhoods, message=FALSE}

da_results <- testNhoods(milo, design = ~ SampleGroup, design.df = milo_design, reduced.dim = "corrected")

da_results %>%
  arrange(SpatialFDR) %>%
  head()
```

### Inspecting DA results

We can start inspecting the results of our DA analysis from a couple of standard diagnostic plots. We first inspect the distribution of uncorrected P values, to verify that the test was balanced. We expect a peak to very low extreme and a tail towards 1. This blog (article)[http://varianceexplained.org/statistics/interpreting-pvalue-histogram/] explains the different pvalue histogram profiles and what they can mean.

```{r plot_DA_pvalue_histogram, message=FALSE}

ggplot(da_results, aes(PValue)) + geom_histogram(bins=50)
```

Then we visualize the test results with a volcano plot (remember that each point here represents a neighbourhood, not a cell).

We have marked a significance threshold of 10% FDR.

```{r plot_DA_volcano, message=FALSE}
ggplot(da_results, aes(logFC, -log10(SpatialFDR))) + 
  geom_point() +
  geom_hline(yintercept = 1) 
```

It looks like we have detected several neighbourhoods were there is a significant difference in cell abundances between sample groups.

To visualize DA results relating them to the embedding of single cells, we can build an abstracted graph of neighbourhoods that we can superimpose on the single-cell embedding. 

```{r build_neighbourhood_graph, message=FALSE}
milo <- buildNhoodGraph(milo)

```

In a normal analysis it is assumed that by stage we would have divided our cells in a biological meaningful way, be that using the cluster marker to define cell types or another method so we can use that as an overlay to help us make sense of the downstream functionality Milo supplies. In this demonstration we have not conclusively done this so we will just use our cluster numbers as a placeholder.
 
Here each node represents a neighbourhood, while edges indicate how many cells two neighbourhoods have in common. Here the layout of nodes is determined by the position of the index cell in the UMAP embedding of all single-cells. The neighbourhoods displaying significant DA are colored by their log-Fold Change.

```{r plot_umap_neighbourhood_combined, message=FALSE}

umap_plot <- plotReducedDim(milo, dimred = "UMAP_corrected", colour_by="label", text_by = "label")

nh_graph_plot <- plotNhoodGraphDA(milo, da_results, layout="UMAP_corrected",alpha=0.05)

umap_plot + nh_graph_plot +
  plot_layout(guides="collect")
```

We might also be interested in visualizing whether DA is particularly evident in certain labels (or celltypes). To do this, we assign a label to each neighbourhood by finding the most abundant label within cells in each neighbourhood. We can label neighbourhoods in the results data.frame using the function annotateNhoods. This also saves the fraction of cells harboring the label.

```{r annotate_neighbourhoods, message=FALSE}

da_results <- annotateNhoods(milo, da_results, coldata_col = "label")
head(da_results)
```

We can plot to see what the distribution of neighbourhoods is like within our labels. We could take this as a measure of how similar our clustering is with the KNN neighborhood as defined by Milo.

```{r plot_label_fraction, message=FALSE}
ggplot(da_results, aes(label_fraction)) + geom_histogram(bins=50)
```

While neighbourhoods tend to be homogeneous, we can define a threshold for label_fraction to exclude neighbourhoods that are a mix of cell types.

```{r excluded_mixed_neighbourhoods, message=FALSE}

da_results$label <- ifelse(da_results$label_fraction < 0.7, "Mixed", da_results$label)

head(da_results)
```

Now we can visualise the distribution of DA Fold Changes in different labels.

```{r beeswarm_plot_by_label, message=FALSE}

plotDAbeeswarm(da_results, group.by = "label")
```

This is already quite informative, we can see in several clusters are enrich and some are depleted between our sample groups. There are not many DA neighbourhoods with a mixed label either.

### Finding markers of DA populations

Once you have found your neighbourhoods showing significant DA between conditions, you might want to find gene signatures specific to the cells in those neighbourhoods. The function findNhoodGroupMarkers runs a one-VS-all differential gene expression test to identify marker genes for a group of neighbourhoods of interest. Before running this function you will need to define your neighbourhood groups depending on your biological question. This needs to be stored as a NhoodGroup column in the da_results data.frame.

#### Custom grouping of neighbourhoods

In a case where all the DA neighbourhoods seem to belong to the same region of the graph, you might just want to test the significant DA neighbourhoods with the same logFC against all the rest. Here is a demonstration using a random set of 10 genes.

```{r custom_example_metadata, purl=FALSE, message=FALSE}
da_results$NhoodGroup <- as.numeric(da_results$SpatialFDR < 0.1 & da_results$logFC < 0)
da_nhood_markers <- findNhoodGroupMarkers(milo, da_results, subset.row = rownames(milo)[1:10])

head(da_nhood_markers)
```

For this analysis we recommend aggregating the neighbourhood expression profiles by experimental samples (the same used for DA testing), by setting aggregate.samples=TRUE. This way single-cells will not be considered as “replicates” during DGE testing, and dispersion will be estimated between true biological replicates. Like so:

```{r find_neighbourhood_group_markers_custom_example, purl = FALSE, message=FALSE}
da_nhood_markers <- findNhoodGroupMarkers(milo, da_results, subset.row = rownames(milo)[1:10], 
                                          aggregate.samples = TRUE, sample_col = "SampleName")
head(da_nhood_markers)
```

#### Automatic grouping of neighbourhoods

In many cases, such as this example, DA neighbourhoods are found in different areas of the KNN graph, and grouping together all significant DA populations might not be ideal, as they might include cells of very different celltypes. For this kind of scenario, we have implemented a neighbourhood function that uses community detection to partition neighbourhoods into groups on the basis of (1) the number of shared cells between 2 neighbourhoods; (2) the direction of fold-change for DA neighbourhoods; (3) the difference in fold change. This is done using the Louvain community detection algorithm.

The max.lfc.delta argument here determines the absolute difference in log fold change below which neighbourhoods should not be considered adjacent. The overlap argument determines the number of cells that must overlap between adjacent neighbourhoods for merging and there is a default FDR of 0.1 for determining which neighbourhoods are considered DA.

```{r autogroup, message=FALSE}

da_results <- groupNhoods(milo, da_results, max.lfc.delta = 10, overlap = 1)
head(da_results)

```

We can view this on a UMAP.

```{r grouped_umap, message=FALSE}
plotNhoodGroups(milo, da_results, layout="UMAP_corrected") 
```

And on a bee swarm plot.

```{r grouped_beeswarm, message=FALSE}
plotDAbeeswarm(da_results, "NhoodGroup")

```

## Exercise 2

:::exercise

See the accompanying worksheet for this session, which includes the code below
for the exercise. We want to achieve the following:

- Change the values for `max.lfc.delta` and `overlap` to see how the grouping is affected.

```{r exercise2, eval=FALSE}
# First load in the other two sample groups
set.seed(42) # set your random seed for reproducibility

# Part A
# rerun the grouping with values for max.lfc.delta of 1, 5, 25 and plot beeswarm for each

plotDAbeeswarm(groupNhoods(milo, da_results, max.lfc.delta = FIXME) , group.by = "NhoodGroup") + ggtitle("max LFC delta=1")


# Part B
# Using the max.lfc.delta you preferred from Part A now alter the overlap value trying 1, 3, 10.

FIXME

```

<details><summary>Hint A</summary>

Replace the max.lfc.delta value to get the new beeswarm plot. Overlap is defaulted to 1 so we can just leave that for now.

</details>

<details><summary>Hint B</summary>

Add the overlap argument into the groupNhoods function and try the different values suggested.

</details>

<details><summary>Answer</summary>

Here is the complete script: 

```{r exercise2_solution, eval=FALSE}
# First load in the other two sample groups
set.seed(42) # set your random seed for reproducibility

# Part A
# rerun the grouping with values for max.lfc.delta of 1, 5, 25 and plot beeswarm for each

plotDAbeeswarm(groupNhoods(milo, da_results, max.lfc.delta = 1) , group.by = "NhoodGroup") + ggtitle("max LFC delta=1")

plotDAbeeswarm(groupNhoods(milo, da_results, max.lfc.delta = 5) , group.by = "NhoodGroup") + ggtitle("max LFC delta=5")

plotDAbeeswarm(groupNhoods(milo, da_results, max.lfc.delta = 25) , group.by = "NhoodGroup") + ggtitle("max LFC delta=25")

# Part B
# Using the max.lfc.delta you preferred from Part A now alter the overlap value trying 1, 3, 10.

plotDAbeeswarm(groupNhoods(milo, da_results, max.lfc.delta = 5, overlap = 1) , group.by = "NhoodGroup") + ggtitle("overlap=1")

plotDAbeeswarm(groupNhoods(milo, da_results, max.lfc.delta = 5, overlap = 3) , group.by = "NhoodGroup") + ggtitle("overlap=3")

plotDAbeeswarm(groupNhoods(milo, da_results, max.lfc.delta = 5, overlap = 10) , group.by = "NhoodGroup") + ggtitle("overlap=10")

# The final code

set.seed(42)
da_results <- groupNhoods(milo, da_results, max.lfc.delta = 5, overlap=1)
plotNhoodGroups(milo, da_results, layout="UMAP_corrected")
plotDAbeeswarm(da_results, group.by = "NhoodGroup")

```

</details>

:::

### Finding gene signatures for neighbourhoods

Once we have grouped neighbourhoods using groupNhoods we are now all set to identifying gene signatures between neighbourhood groups.

Let’s restrict the testing to highly variable genes in this case

```{r get_hvgs, message=FALSE}
set.seed(101)
dec <- modelGeneVar(milo)
hvgs <- getTopHVGs(dec, n=2000)
head(hvgs)
```

We run findNhoodGroupMarkers to test for one-vS-all differential gene expression for each neighbourhood group

```{r get_neighbourhood_group_markers, message=FALSE}
set.seed(42)
nhood_markers <- findNhoodGroupMarkers(milo, da_results, subset.row = hvgs, 
                                       aggregate.samples = TRUE, sample_col = "SampleName")
head(nhood_markers)
```

We can get the markers that define a specific group.

```{r group_9_markers, message=FALSE}
gr9_markers <- nhood_markers[c("logFC_9", "adj.P.Val_9","GeneID")] 
colnames(gr9_markers) <- c("logFC", "adj.P.Val", "GeneID")
head(gr9_markers[order(gr9_markers$adj.P.Val), ])
```
We can start to do many visualisation and further investigations of the data using these grouping. More details are avalible in the Milo documentation.

```{r plot_group_markers, message=FALSE}
markers <- nhood_markers$GeneID[nhood_markers$adj.P.Val_9 < 0.01 
                                & nhood_markers$logFC_9 > 0]

plotNhoodExpressionGroups(milo, da_results, features=intersect(rownames(milo), markers[1:10]),
                          subset.nhoods = da_results$NhoodGroup %in% c('6','9'), 
                          scale=TRUE,
                          grid.space = "fixed")
```


## Session information

<details>
```{r}
sessionInfo()
```
</details>
